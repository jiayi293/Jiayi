# -*- coding: utf-8 -*-
"""DLW_FinalV.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NtJfxAt2gHN8j6b36wUoUMoHDoNZaQcZ
"""

from google.colab import files
import zipfile
import os

# ZIP file
uploaded = files.upload()

original_filename = list(uploaded.keys())[0]
new_filename = "injury.zip"

# File renaming
os.rename(original_filename, new_filename)

import shutil

zip_path = "injury.zip"
extract_to = "injury_dataset"

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_to)

 # Show folders inside
print("Extracted Folders:", os.listdir(extract_to))

import os
import shutil
import random


extracted_path = "injury_dataset"
dataset_dir = "Organized_dataset"
train_folder = os.path.join(dataset_dir, "train")
test_folder = os.path.join(dataset_dir, "test")

os.makedirs(train_folder, exist_ok=True)
os.makedirs(test_folder, exist_ok=True)

# Loop through each category folder
for category in os.listdir(extracted_path):
    category_path = os.path.join(extracted_path, category)

    if os.path.isdir(category_path):
        train_category_path = os.path.join(train_folder, category)
        test_category_path = os.path.join(test_folder, category)

        os.makedirs(train_category_path, exist_ok=True)
        os.makedirs(test_category_path, exist_ok=True)

        # Image files
        image_files = [f for f in os.listdir(category_path) if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
        random.shuffle(image_files)

        # Split dataset (80% train, 20% test)
        split_index = int(0.8 * len(image_files))
        train_images = image_files[:split_index]
        test_images = image_files[split_index:]

        for img in train_images:
            shutil.move(os.path.join(category_path, img), os.path.join(train_category_path, img))

        for img in test_images:
            shutil.move(os.path.join(category_path, img), os.path.join(test_category_path, img))

import os
import matplotlib.pyplot as plt
import random
from tensorflow.keras.preprocessing.image import load_img

train_path = "Organized_dataset/train"
test_path = "Organized_dataset/test"

def visualize_data_split(train_path, test_path, num_samples=5):
    categories = os.listdir(train_path)

    plt.figure(figsize=(10, 5))

    # Display train set images
    for i, category in enumerate(categories[:num_samples]):
        train_category_path = os.path.join(train_path, category)
        train_images = os.listdir(train_category_path)

        if train_images:
            img_path = os.path.join(train_category_path, random.choice(train_images))
            img = load_img(img_path)
            plt.subplot(2, num_samples, i + 1)
            plt.imshow(img)
            plt.axis("off")
            plt.title(f"Train: {category}")

    # Display test set images
    for i, category in enumerate(categories[:num_samples]):
        test_category_path = os.path.join(test_path, category)
        test_images = os.listdir(test_category_path)

        if test_images:
            img_path = os.path.join(test_category_path, random.choice(test_images))
            img = load_img(img_path)
            plt.subplot(2, num_samples, num_samples + i + 1)
            plt.imshow(img)
            plt.axis("off")
            plt.title(f"Test: {category}")

    plt.suptitle("Train & Test Set Split Visualization", fontsize=14)
    plt.tight_layout()
    plt.show()

visualize_data_split(train_path, test_path)

from tensorflow.keras.preprocessing.image import ImageDataGenerator

IMG_SIZE = (128, 128)
BATCH_SIZE = 32

train_path = "Organized_dataset/train"
test_path = "Organized_dataset/test"

train_datagen = ImageDataGenerator(rescale=1.0/255)
test_datagen = ImageDataGenerator(rescale=1.0/255)

# Training Images
train_generator = train_datagen.flow_from_directory(
    train_path,
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode='categorical'
)

# Testing Images
test_generator = test_datagen.flow_from_directory(
    test_path,
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode='categorical',
    shuffle=False
)

print("Images successfully loaded into CNN model!")

from tensorflow.keras.preprocessing.image import ImageDataGenerator

IMG_SIZE = (128, 128)
BATCH_SIZE = 32

train_path = "organized_dataset/train"
test_path = "organized_dataset/test"

train_datagen = ImageDataGenerator(rescale=1.0/255)
test_datagen = ImageDataGenerator(rescale=1.0/255)

# Training Images
train_generator = train_datagen.flow_from_directory(
    train_path,
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode='categorical'
)

# Testing Images
test_generator = test_datagen.flow_from_directory(
    test_path,
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode='categorical',
    shuffle=False
)

print("Images successfully loaded into CNN model!")

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, Input
from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Data Augmentation
train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=40,
    width_shift_range=0.3,
    height_shift_range=0.3,
    shear_range=0.3,
    zoom_range=0.3,
    horizontal_flip=True,
    fill_mode='nearest'
)

test_datagen = ImageDataGenerator(rescale=1./255)

# CNN Model
model = Sequential([
    Input(shape=(128, 128, 3)),
    Conv2D(32, (3, 3), activation='relu'),
    MaxPooling2D(2, 2),

    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D(2, 2),

    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D(2, 2),

    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.6),
    Dense(8, activation='softmax')
])

model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

early_stopping = EarlyStopping(monitor='val_loss', patience=3, restore_best_weights=True)
reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=2, min_lr=1e-6, verbose=1)

history = model.fit(
    train_generator,
    epochs=15,
    validation_data=test_generator,
    callbacks=[early_stopping, reduce_lr]
)

model.save("injury_classification_cnn.keras")

plot_history(history)

import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator


# Load trained model
model = tf.keras.models.load_model("injury_classification_cnn.keras")

test_datagen = ImageDataGenerator(rescale=1./255)

test_generator = test_datagen.flow_from_directory(
    "organized_dataset/test",
    target_size=(128, 128),
    batch_size=32,
    class_mode="categorical",
    shuffle=False
)

predictions = model.predict(test_generator)

print("Predictions Shape:", predictions.shape)
print("Class Labels:", test_generator.class_indices)
print("Number of Classes:", len(test_generator.class_indices))

class_labels = list(test_generator.class_indices.keys())

predicted_classes = []
for i, pred in enumerate(predictions):
    pred_idx = np.argmax(pred)
    if pred_idx < len(class_labels):
        predicted_classes.append(class_labels[pred_idx])
    else:
        print(f"Warning: Invalid index {pred_idx} for image {i}")
        predicted_classes.append("Unknown")

actual_filenames = test_generator.filenames

# Predictions for the first 100 test images
num_samples = min(100, len(actual_filenames))
for i in range(num_samples):
    print(f"Image: {actual_filenames[i]} - Predicted: {predicted_classes[i]}")

import numpy as np
import tensorflow as tf
from sklearn.metrics import classification_report

model = tf.keras.models.load_model("injury_classification_cnn.keras")

if "test_generator" not in locals():
    print("Error: test_generator is not defined. Make sure it's initialized before predicting.")
else:
    predictions = model.predict(test_generator)

    class_labels = list(test_generator.class_indices.keys())
    class_labels.pop(7)

    predicted_classes = np.argmax(predictions, axis=1)
    true_classes = test_generator.classes

    print("Classification Report:\n", classification_report(true_classes, predicted_classes, target_names=class_labels))